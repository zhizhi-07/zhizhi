# 表情包逻辑重构方案

## 🎯 目标

重新设计一个清晰、简单、可靠的表情包系统。

## 📋 核心原则

1. **简单明了** - 逻辑清晰，易于理解和维护
2. **格式统一** - 只有一种表情包格式
3. **错误容忍** - 自动处理错误格式
4. **上下文清晰** - 区分"给 AI 看的"和"AI 发送的"

## 🔄 完整流程

### 1. 用户发送表情包

```
用户点击表情包
  ↓
创建表情包消息对象
  {
    messageType: 'emoji',
    emojiUrl: '图片URL',
    emojiDescription: '描述'
  }
  ↓
显示在聊天界面
  ↓
保存到消息历史
```

### 2. 构建 AI 上下文

```
读取消息历史
  ↓
转换为 AI 可理解的格式
  - 文字消息: 直接传递
  - 表情包消息: 转换为 "[对方发了表情包]"
  ↓
传递给 AI
```

**关键：** 这里的 `[对方发了表情包]` 只是给 AI 看的上下文，不是消息内容！

### 3. AI 回复处理

```
AI 返回回复
  ↓
解析回复内容
  - 提取表情包标记: [表情包:数字]
  - 提取文字内容
  - 清理所有标记
  ↓
创建消息对象
  - 如果有文字: 创建文字消息
  - 如果有表情包: 创建表情包消息
  ↓
显示在聊天界面
```

## 🔧 技术实现

### 步骤 1: 表情包格式定义

**唯一正确的格式：**
```
[表情包:数字]
```

**示例：**
- ✅ `[表情包:0]` - 正确
- ✅ `[表情包:1]` - 正确
- ❌ `[表情包:哈哈哈]` - 错误（不能用描述）
- ❌ `[表情包: 0]` - 错误（有空格）
- ❌ `[我发了表情包]` - 错误（这是上下文标记）

### 步骤 2: 上下文标记定义

**给 AI 看的标记（不是消息内容）：**
```
[对方发了表情包]  - 用户发的表情包
[我发了表情包]    - AI 发的表情包（不应该出现在 AI 回复中）
```

### 步骤 3: 解析 AI 回复

```typescript
function parseAIResponse(aiResponse: string, availableEmojis: Emoji[]) {
  const result = {
    textContent: '',
    emojiIndexes: [] as number[],
    hasError: false
  }
  
  // 1. 提取正确格式的表情包
  const emojiMatches = aiResponse.matchAll(/\[表情包:(\d+)\]/g)
  for (const match of emojiMatches) {
    const index = parseInt(match[1])
    if (index >= 0 && index < availableEmojis.length) {
      result.emojiIndexes.push(index)
    } else {
      console.warn('无效的表情包索引:', index)
      result.hasError = true
    }
  }
  
  // 2. 移除所有表情包标记（正确和错误的）
  let cleaned = aiResponse
  cleaned = cleaned.replace(/\[表情包:\d+\]/g, '') // 正确格式
  cleaned = cleaned.replace(/\[表情包:[^\]]+\]/g, '') // 错误格式
  
  // 3. 移除上下文标记（AI 不应该发送这些）
  cleaned = cleaned.replace(/\[我发了表情包\]/g, '')
  cleaned = cleaned.replace(/\[对方发了表情包\]/g, '')
  
  // 4. 清理空白
  result.textContent = cleaned.trim()
  
  return result
}
```

### 步骤 4: 创建消息

```typescript
async function createAIMessages(parsed: ParseResult, availableEmojis: Emoji[]) {
  const messages: Message[] = []
  
  // 1. 如果有文字内容，创建文字消息
  if (parsed.textContent) {
    messages.push({
      id: Date.now(),
      type: 'received',
      content: parsed.textContent,
      time: getCurrentTime(),
      messageType: 'text'
    })
  }
  
  // 2. 如果有表情包，创建表情包消息
  for (const index of parsed.emojiIndexes) {
    const emoji = availableEmojis[index]
    if (emoji) {
      messages.push({
        id: Date.now() + index,
        type: 'received',
        content: '',
        time: getCurrentTime(),
        messageType: 'emoji',
        emojiUrl: emoji.url,
        emojiDescription: emoji.description
      })
    }
  }
  
  return messages
}
```

### 步骤 5: 构建对话历史

```typescript
function buildConversationHistory(messages: Message[]) {
  return messages.map(msg => {
    // 表情包消息转换为上下文标记
    if (msg.messageType === 'emoji') {
      const context = msg.type === 'sent' 
        ? '[对方发了表情包]'  // 用户发的
        : '[我发了表情包]'    // AI 发的
      
      return {
        role: msg.type === 'sent' ? 'user' : 'assistant',
        content: context
      }
    }
    
    // 文字消息直接传递
    return {
      role: msg.type === 'sent' ? 'user' : 'assistant',
      content: msg.content
    }
  })
}
```

## 📝 提示词优化

### 给 AI 的说明

```
【表情包使用规则】

你可以发送表情包，格式必须是：[表情包:数字]

可用的表情包列表：
0: 哈哈哈
1: 点赞
2: OK
...

重要规则：
1. 只能使用数字索引，不能使用描述文字
   ✅ 正确：[表情包:0]
   ❌ 错误：[表情包:哈哈哈]

2. 表情包可以单独发送，也可以和文字一起发送
   ✅ 正确：好的[表情包:0]
   ✅ 正确：[表情包:0]
   
3. 不要发送这些内容：
   ❌ [我发了表情包]
   ❌ [对方发了表情包]
   这些是系统标记，不是消息内容

4. 如果对方发了表情包，你会看到 "[对方发了表情包]"
   你可以回复文字，也可以回复表情包，或者都不回复
```

## 🧪 测试用例

### 用例 1: AI 正确发送表情包

**输入：**
```
AI 回复: "好的[表情包:0]"
```

**处理：**
```typescript
parsed = {
  textContent: "好的",
  emojiIndexes: [0],
  hasError: false
}
```

**输出：**
```
消息 1: "好的" (文字)
消息 2: [表情包图片] (表情包)
```

### 用例 2: AI 错误使用描述

**输入：**
```
AI 回复: "好的[表情包:哈哈哈]"
```

**处理：**
```typescript
parsed = {
  textContent: "好的",
  emojiIndexes: [],
  hasError: true
}
```

**输出：**
```
消息 1: "好的" (文字)
控制台: ⚠️ AI 使用了错误的表情包格式
```

### 用例 3: AI 误发上下文标记

**输入：**
```
AI 回复: "[我发了表情包]"
```

**处理：**
```typescript
parsed = {
  textContent: "",
  emojiIndexes: [],
  hasError: false
}
```

**输出：**
```
(无消息，因为清理后内容为空)
```

### 用例 4: 用户发表情包后 AI 回复

**对话历史传给 AI：**
```
user: "你好"
assistant: "你好呀"
user: "[对方发了表情包]"  ← 用户发的表情包
```

**AI 回复：**
```
"哈哈哈"
或
"[表情包:0]"
或
"哈哈哈[表情包:0]"
```

## ✅ 优势

### 1. 逻辑清晰

- 上下文标记和消息内容完全分离
- 解析逻辑简单明了
- 易于调试和维护

### 2. 错误容忍

- 自动清理错误格式
- 不会因为 AI 错误而崩溃
- 提供清晰的错误日志

### 3. 用户体验

- 不会看到奇怪的标记
- 表情包正常显示
- AI 回复自然

## 🔄 迁移步骤

### 步骤 1: 创建新的解析函数

创建 `src/utils/emojiParser.ts`：
```typescript
export function parseAIResponse(
  aiResponse: string,
  availableEmojis: Emoji[]
): {
  textContent: string
  emojiIndexes: number[]
  hasError: boolean
}
```

### 步骤 2: 更新 ChatDetail.tsx

替换现有的表情包解析逻辑，使用新的解析函数。

### 步骤 3: 更新提示词

简化表情包使用说明，使其更清晰。

### 步骤 4: 测试

- 测试用户发送表情包
- 测试 AI 发送表情包
- 测试错误格式处理
- 测试上下文标记清理

## 📊 预期效果

- ✅ 表情包功能完全正常
- ✅ 不会出现 `[我发了表情包]` 这样的文字
- ✅ AI 能正确理解和发送表情包
- ✅ 代码清晰易维护

---

**重构时间**: 2025-10-19  
**目标**: 彻底解决表情包逻辑问题
